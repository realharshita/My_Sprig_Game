/*
In "Quantum Escape," players control a scientist who accidentally gets trapped in a quantum computer 
simulation. The game combines puzzle-solving with platforming elements, set in a visually abstract and 
ever-changing digital environment.

Key Features:
@title: Quantum Escape
@author: Harshita
@tags: []
@addedOn: 2024-00-00
*/

const player = "p"
const box = "b"
const entangled_box_red_a = "e"
const entangled_box_red_b = "f"
const black_hole = "t" 
const wall = "w"

setLegend(
  [ player, bitmap`
................
................
................
.....L....L.....
.....LL..LL.....
.....000000.....
...L.0....0.L...
....L07..70L....
.....0.LL.0.....
.....0.33.0.....
.....000000.....
.....LL..LL.....
.....L....L.....
................
................
................` ],
  [ box, bitmap`
................
................
................
................
................
.....000000.....
.....000000.....
.....000000.....
.....000000.....
.....000000.....
.....000000.....
................
................
................` ],
  [ entangled_box_red_a, bitmap`
................
................
................
................
................
.....030303.....
.....303030.....
.....030300.....
.....303000.....
.....030000.....
.....300000.....
................
................
................` ],
  [ entangled_box_red_b, bitmap`
................
................
................
................
................
.....000003.....
.....000030.....
.....000303.....
.....003030.....
.....030303.....
.....303030.....
................
................
................` ],
  [ black_hole, bitmap`
....00000000000.
...000.....00000
.0000LLLLL..0000
000..L...LLL..00
00.LLL.11..LLL.0
00.L..111111.L.0
0.LL.1222.11.L.0
0.L.112.2..1.L.0
0.L.1.2.22.1.L.0
0.L.11222211.L.0
0.LL.11..11.LL.0
00.LL.1111.LL.00
000.LL.....L..00
.00..LLLLLLL.00.
..000000...0000.
...0000000000...` ],
  [ wall, bitmap`
................
................
................
................
................
.....C.C.C.C....
.....3C3C3C3....
.....C3C3C3C....
.....3C3C3C3....
.....C3C3C3C....
.....3C3C3C3....
................
................
................` ]
)

setSolids([ player, box, wall, entangled_box_red_b, entangled_box_red_a ]); 
let level = 0
const levels = [
  map`
p.....
..b...
..t...
..w...`,
  map`
..p.........
.....b..t...
..e...f.....
............
....w.......`,
  map`
p.....
..b...
..t...
..w...`, 
  map`
p.....
..b...
..t...
..w...`,
  map`
p.....
..b...
..t...
..w...`
]

setMap(levels[level])

const allBoxTypes = [box, entangled_box_red_a, entangled_box_red_b]; 
setPushables({
  [player]: allBoxTypes
});

function moveEntangledBoxes(playerSprite, dx, dy) {
  const entangledBoxA = getFirst(entangled_box_red_a);
  const entangledBoxB = getFirst(entangled_box_red_b);
  
  if (entangledBoxA && entangledBoxB) {
    const newPosX = playerSprite.x - dx;
    const newPosY = playerSprite.y - dy;
  
    entangledBoxA.x = newPosX + dx;
    entangledBoxA.y = newPosY + dy;
  
    entangledBoxB.x = newPosX - dx;
    entangledBoxB.y = newPosY - dy;
  }
}

onInput("s", () => {
  const playerSprite = getFirst(player);
  playerSprite.y += 1;
  moveEntangledBoxes(playerSprite, 0, -1);
});

onInput("w", () => {
  const playerSprite = getFirst(player);
  playerSprite.y -= 1;
  moveEntangledBoxes(playerSprite, 0, 1);
});

onInput("a", () => {
  const playerSprite = getFirst(player);
  playerSprite.x -= 1;
  moveEntangledBoxes(playerSprite, 1, 0);
});

onInput("d", () => {
  const playerSprite = getFirst(player);
  playerSprite.x += 1;
  moveEntangledBoxes(playerSprite, -1, 0);
});

let gameCompleted = false;

afterInput(() => {
  if (!gameCompleted) {
    const remainingBoxTypes = allBoxTypes.filter(type => getAll(type).length > 0);

    if (remainingBoxTypes.length === 0) {
      level++;
      if (level < levels.length) {
        setMap(levels[level]);
      } else {
        clearText(); 
        addText("Game End", { x: (width() - 8) / 2, y: height() / 2, color: color`c` }); 
        gameCompleted = true; 
      }
    }

    allBoxTypes.forEach(type => {
      const boxSprites = getAll(type);
      const black_holeTileSprites = getTile(getFirst(black_hole).x, getFirst(black_hole).y);
      
      boxSprites.forEach(boxSprite => {
        if (black_holeTileSprites.includes(boxSprite)) {
          boxSprite.remove(); 
        }
      });
    });

    if (!gameCompleted) {
      clearText(); 
      addText(`Level: ${level + 1}`, { x: width() - 2, y: 2, color: color`9` }); 
    }
  }
});
